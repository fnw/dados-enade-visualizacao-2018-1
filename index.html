<html>
<meta charset="utf-8"></meta>
<head>
 <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
   integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
   crossorigin=""/>
<title>Index</title>
</head>

<style>
#leafletmap {
  width: 500px;
  height: 500px;
}

</style>
<body>

<!-- Usei o código de quando eu tentei fazer um clone daqueles "batalha de favoritos" -->



<form id="selectvis">
    <label><input type="radio" id="vis1" name="w" value="vis1"> Notas por Estado </input></label>  
    <label><input type="radio" id="vis2" name="w" value="vis2"> Notas por Instituição</input></label> 
</form>

<select id="dropdown">
  <option value="mean">Nota média</option> 
  <option value="top">1% melhores</option>
  <option value="bottom">1% piores</option>
</select>


 <!-- Make sure you put this AFTER Leaflet's CSS -->
<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
   integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
   crossorigin=""></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="crossfilter.min.js"></script>
<script src="constants.js"></script>
<script type="text/javascript">

//Variáveis globais do mapa do Leaflet

var myMap = null;
var div = d3.select("body").append("div").attr("id","leafletmap");
var geoLayer = null;
var JSONData = null;
var popup = L.popup()

//Variáveis de estado
var selectedVis = null;

//Variáveis de dados

var entireData = null;
var cf = null
var gradesDimension = null;
var numStudents = null;


//Seletores e callbacks

//Funções
function drawMapInitial()
{
    myMap = new L.Map("leafletmap", {center: [-10.3333,-53.2], zoom: 4}).addLayer(new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"));
}

//Função que faz a legenda
//Cria uma série de pequenos retângulos com as cores da escala, para representar a escala.
var addLegend = function(target, transformer, width)
{
    textMargin = 30
    leftMargin = 15
    //Eu usei let aqui porque eu vi um exemplo de coisas dando errado com var quando você usa múltiplas cópias de uma mesma função de certas formas.
    //Além do tamanho dos retângulos, deixamos uma margem para o texto.
    let svg = target.append("svg").attr("width",width + leftMargin + 30).attr("height",20 + textMargin + 5).attr("id","legend")

    let squareWidth = 5

    let [lb,ub] = transformer.domain()

    //Uma escala para converter a posição do retângulo no svg para uma cor da escala.
    let posScaler = d3.scaleLinear().domain([0,width]).range(transformer.domain())

    //Adicionando o texto com os limites superiores e inferiores da escala.
    svg.append("text").attr("x",0).attr("y",15).text(lb)
    svg.append("text").attr("x",width - squareWidth).attr("y",15).text(ub)

	for(let pos = 0; pos < width; pos += squareWidth)
	{
		v = posScaler(pos)

		svg.append("rect").attr("x",leftMargin + pos).attr("y",textMargin+5).attr("width",squareWidth).attr("height",20).attr("fill",transformer(v)).attr("v",v).attr("fill-opacity",0.3)
	}
}

function drawStatesVis(error,data)
{

  


    function countStudentsByState()
    {
        let raw = d3.nest().key(function(d) { return d.CO_UF_CURSO; })
                 .rollup(function(v) { return v.length;})
                 .entries(entireData)

        let countByState = {}
        for(let i = 0; i < raw.length ; i++)
        {
            let k = raw[i].key
            countByState[k] = raw[i].value
            
        }
        return countByState          
    }

    //Fraction of the best students over the fraction of students from the state
    
    function normalizeCounts(counts, totalBestStudents, countByState, numStudents)
    {
        for(let i = 0; i < counts.length ; i++)
        {
            debugger        
            counts[i].value = (counts[i].value/totalBestStudents)/(countByState[counts[i].key]/numStudents)
        }
    }

    function addGeoLayer(arr)
    {
        let dict = {}
              
        arr.forEach(d=>dict[statesCodes[d.key]] = d.value)
               
        let domain = d3.extent(arr,d=>d.value)
        domain[0] = Math.round((0.9 * domain[0]*1000))/1000
        domain[1] = Math.round((1.1 * domain[1]*1000))/1000
        
    	let colorScaler = d3.scaleSequential(d3.interpolateWarm).domain(domain)
    	
    	function whenClicked(e) 
        {
            let popupString = e.target.feature.properties.name
            popupString += ': '
            popupString += dict[e.target.feature.properties.sigla].toFixed(2)
            
            popup
            .setLatLng(e.latlng)
            .setContent(popupString)
            .openOn(myMap); 
        }

        function onEachFeature(feature, layer)
        {
            layer.on({
                click: whenClicked
            });
        }
    	
    	function featureStyle(feature)
        {
            let featureDict = {
                "fillColor": colorScaler(dict[feature.properties.sigla]),
                "color":"black",
                "stroke":false,
                "fillOpacity":0.3
            }
            return featureDict
        }
        geoLayer = L.geoJSON(JSONData,{style: featureStyle, onEachFeature: onEachFeature}).addTo(myMap);
    	addLegend(d3.select("body"), colorScaler, 500)
    }   
    
    function drawBottom()
    {
    
        function isNumeric(n)
        {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
        
        gradesDimension.filter(d=>isNumeric(d))
        
        let top1value = 0.01 * cf.size()
        
        let top1 = gradesDimension.bottom(top1value) 
        
        let countsByState = d3.nest()
                            .key(function(d) { return d.CO_UF_CURSO; })
                            .rollup(function(v) { return v.length;})
                            .entries(top1)
        let allCounts = countStudentsByState()
        normalizeCounts(countsByState, top1value, allCounts, cf.size())
                    
        addGeoLayer(countsByState)
    	
    	gradesDimension.filterAll()
    }
    
    function drawTop()
    {
        let top1value = 0.01 * cf.size()
        
        let top1 = gradesDimension.top(top1value) 
        
        let countsByState = d3.nest()
                            .key(function(d) { return d.CO_UF_CURSO; })
                            .rollup(function(v) { return v.length;})
                            .entries(top1)
        
        let allCounts = countStudentsByState()
        normalizeCounts(countsByState, top1value, allCounts, cf.size())
        
        addGeoLayer(countsByState)
    }
    
    function drawMean()
    {        
        let gradesByState = d3.nest()
                            .key(function(d) { return d.CO_UF_CURSO; })
                            .rollup(function(v) { return d3.mean(v, function(d) { return d.NT_GER; }); })
                            .entries(entireData)
                            
        addGeoLayer(gradesByState)
    }
    
    function draw()
    {
        if(selectedVis == 'mean')
        {
            drawMean()
        }
        else if(selectedVis == 'top')
        {
            drawTop()
        }
        else if(selectedVis == 'bottom')
        {
            drawBottom()
        }
    }
    
    function fillCF()
    {
        cf = crossfilter(entireData)
        
        gradesDimension = cf.dimension(d=>d.NT_GER)   
    }
    
    function fillAndDraw(error,csv)
    {
        entireData = csv 
        
        if(selectedVis == 'top' || selectedVis == 'bottom')
        {
            fillCF()
        }
         
        draw()     
    }

    if(JSONData == null)
    {
        JSONData = data;
    }
    
    
    if(entireData == null)
    {
        console.log('Era null')
        d3.csv('dados_enade.csv').get(fillAndDraw)
    }
    else
    {	
        if((selectedVis == 'top' || selectedVis == 'bottom') && cf == null)
        {
           fillCF()
        }
    
        draw()
    }
}


function drawInstitutionsVis(error,data)
{  
    let extentDict = null;
    
    function countsByInstitution()
    {
        let raw = d3.nest().key(function(d) { return d.CO_IES; })
                 .rollup(function(v) { return v.length;})
                 .entries(entireData)

        let countByInstitution = {}
        for(let i = 0; i < raw.length ; i++)
        {
            let k = raw[i].key
            countByInstitution[k] = raw[i].value
            
        }
        return countByInstitution         
    }

    function normalizeCounts(counts, totalBestStudents, countByInstitution, numStudents)
    {
        for(let i = 0; i < counts.length ; i++)
        {       
            counts[i].value = (counts[i].value/totalBestStudents)/(countByInstitution[counts[i].key]/numStudents)
        }
    }

    function unrollDict(arr)
    {
       return arr.map(e=>e.value)   
    }
   
    function calculateGini(arr)
    {
        let arrValues = unrollDict(arr)
        
        let num = 0
        let den = 0
        
        for(let i = 0 ; i < arrValues.length ; i++)
        {
            for(let j = 0 ; j < arrValues.length; j++)
            {
                num += Math.abs(arrValues[i] - arrValues[j])
            }
        }
        
        for(let i = 0 ; i <arr.length ; i++)
        {
            den += arrValues[i]
        }
        
        return num/(2*arrValues.length*den);  
    }
    
    function getExtent(dict)
    {
        let unrolled = dict.map(e=>e.values.map(f=>f.value))
        
        let newDict = {}
        
        for(let i = 0 ; i < unrolled.length; i++)
        {
            let extent = d3.extent(unrolled[i])
            
            newDict[statesCodes[dict[i].key]] = extent
        }
        
        return newDict
    }
    
    
    
    function addGeoLayer(arr)
    {
        let newArr = []
        for(let i = 0; i < arr.length ; i++)
        {
            let k = arr[i].key
            let newObj = {}
            newObj['key'] = k
            newObj['value'] = calculateGini(arr[i].values)
            newArr.push(newObj)
        }
        
        let dict = {}
              
        newArr.forEach(d=>dict[statesCodes["" + d.key]] = d.value)
     
        let domain = d3.extent(newArr,d=>d.value)
        
        domain[0] = Math.round((0.9 * domain[0]*1000))/1000
        domain[1] = Math.round((1.1 * domain[1]*1000))/1000
        
    	let colorScaler = d3.scaleSequential(d3.interpolateWarm).domain(domain)
    	
    	function whenClicked(e) 
        {
            let popupString = e.target.feature.properties.name
            popupString += ': '
            popupString += dict[e.target.feature.properties.sigla].toFixed(2)
            
            let t = null
            
            if(selectedVis == 'mean')
            {
                t = 'Nota'
            }
            else
            {
                t = 'Contagem'
            }
            
            popupString += '<br/>'
            popupString += t
            popupString += ' mínima: '
            popupString += extentDict[e.target.feature.properties.sigla][0]
            
            popupString += '<br/>'
            popupString += t
            popupString += ' máxima: '
            popupString += extentDict[e.target.feature.properties.sigla][1]
            
            
            popup
            .setLatLng(e.latlng)
            .setContent(popupString)
            .openOn(myMap); 
        }

        function onEachFeature(feature, layer)
        {
            layer.on({
                click: whenClicked
            });
        }
    	
    	
    	function featureStyle(feature)
        {
            let featureDict = {
                "fillColor": colorScaler(dict[feature.properties.sigla]),
                "color":"black",
                "stroke":false,
                "fillOpacity":0.3
            }
            return featureDict
        }
        
        
        geoLayer = L.geoJSON(JSONData,{style:featureStyle, onEachFeature: onEachFeature}).addTo(myMap);
    	addLegend(d3.select("body"), colorScaler, 500)
    }   
    
    function drawBottom()
    {        
        function isNumeric(n)
        {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
        
        gradesDimension.filter(d=>isNumeric(d))
        
        let top1value = 0.01 * cf.size()
        
        let top1 = gradesDimension.bottom(top1value) 
        
        let countsByState = d3.nest()
                            .key(function(d) { return d.CO_UF_CURSO; })
                            .key(function(d) {return d.CO_IES})
                            .rollup(function(v) { return v.length;})
                            .entries(top1)
                            
        extentDict = getExtent(countsByState)
                            
        let countInst = countsByInstitution()
        countsByState.forEach(e=>normalizeCounts(e.values,top1value,countInst,cf.size()))                     
        
        addGeoLayer(countsByState)
    	
    	gradesDimension.filterAll()
    }
    
    function drawTop()
    {
        let top1value = 0.01 * cf.size()
        
        let top1 = gradesDimension.top(top1value) 
        
        let countsByState = d3.nest()
                            .key(function(d) { return d.CO_UF_CURSO; })
                            .key(function(d) {return d.CO_IES})
                            .rollup(function(v) { return v.length;})
                            .entries(top1)
                            
       extentDict = getExtent(countsByState)                     
       
       let countInst = countsByInstitution()
       countsByState.forEach(e=>normalizeCounts(e.values,top1value,countInst,cf.size()))
                 
       addGeoLayer(countsByState)
    }
    
    function drawMean()
    {        
        let gradesByState = d3.nest().
                            key(function(d) { return d.CO_UF_CURSO})
                            .key(function(d) {return d.CO_IES})
                            .rollup(function(v) { return d3.mean(v, function(d) { return d.NT_GER; }); })
                            .entries(entireData)
                            
        extentDict = getExtent(gradesByState)
        
                            
        addGeoLayer(gradesByState)
    }
    
    function draw()
    {
        if(selectedVis == 'mean')
        {
            drawMean()
        }
        else if(selectedVis == 'top')
        {
            drawTop()
        }
        else if(selectedVis == 'bottom')
        {
            drawBottom()
        }
    }
    
    function fillCF()
    {
        cf = crossfilter(entireData)
        
        gradesDimension = cf.dimension(d=>d.NT_GER)   
    }
    
    function fillAndDraw(error,csv)
    {
        entireData = csv 
        
        if(selectedVis == 'top' || selectedVis == 'bottom')
        {
            fillCF()
        }
         
        draw()     
    }

    if(JSONData == null)
    {
        JSONData = data
    }
    
    if(entireData == null)
    {
        console.log('Era null')
        d3.csv('dados_enade.csv').get(fillAndDraw)
    }
    else
    {	
        if((selectedVis == 'top' || selectedVis == 'bottom') && cf == null)
        {
           fillCF()
        }
    
        draw()
    }
}


var callbackSelectVis = function(event)
{ 
    let radioValue = document.querySelector('input[name="w"]:checked').value;
    
    let de = document.querySelector('select#dropdown')
    let dropdownValue = de.options[de.selectedIndex].value;    
     
    let vis = radioValue + '-' + dropdownValue
    selectedVis = dropdownValue
    
    console.log(selectedVis)
    
    d3.select("svg#legend").remove()
   	
   	if(geoLayer != null)
   	{
   	    myMap.removeLayer(geoLayer)
   	}
	
    
    if(radioValue == "vis1")
    {
        cb = drawStatesVis
    }
    else if(radioValue == "vis2")
    {
        cb = drawInstitutionsVis
    }

    if(JSONData == null)
    {
        d3.json('brazil-states.geojson',cb)
    }
    else
    {
        cb(null, null)
    }
}

var formElement = document.querySelector('form#selectvis')
formElement.addEventListener('change', callbackSelectVis);

var dropdownElement = document.querySelector('select#dropdown')
dropdownElement.addEventListener('change', callbackSelectVis);



drawMapInitial()


</script>

</body>
<html>
