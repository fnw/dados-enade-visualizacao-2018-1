<html>
<meta charset="utf-8"></meta>
<head>
 <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
   integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
   crossorigin=""/>
<title>Problema 2</title>
</head>

<style>
#leafletmap {
  width: 500px;
  height: 500px;
}

</style>
<body>

<!-- Usei o código de quando eu tentei fazer um clone daqueles "batalha de favoritos" -->

<!--

<form id="selectvis">
    <label><input type="radio" id="vis1" name="w" value="vis1"> Acidentes no Mapa </input></label>  
    <label><input type="radio" id="vis2" name="w" value="vis2"> Acidentes por Estado</input></label> 
    <label><input type="radio" id="vis2" name="w" value="vis3"> Acidentes por Município </input></label>   
</form>

-->

 <!-- Make sure you put this AFTER Leaflet's CSS -->
 <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
   integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
   crossorigin=""></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script type="text/javascript">

//Função que faz a legenda
//Cria uma série de pequenos retângulos com as cores da escala, para representar a estala.
var addLegend = function(target, transformer, width)
{
    textMargin = 30
    leftMargin = 15
    //Eu usei let aqui porque eu vi um exemplo de coisas dando errado com var quando você usa múltiplas cópias de uma mesma função de certas formas.
    //Além do tamanho dos retângulos, deixamos uma margem para o texto.
    let svg = target.append("svg").attr("width",width + leftMargin + 30).attr("height",20 + textMargin + 5).attr("id","legend")

    let squareWidth = 5

    let [lb,ub] = transformer.domain()

    //Uma escala para converter a posição do retângulo no svg para uma cor da escala.
    let posScaler = d3.scaleLinear().domain([0,width]).range(transformer.domain())

    //Adicionando o texto com os limites superiores e inferiores da escala.
    svg.append("text").attr("x",0).attr("y",15).text(lb)
    svg.append("text").attr("x",width - squareWidth).attr("y",15).text(ub)

	for(let pos = 0; pos < width; pos += squareWidth)
	{
		v = posScaler(pos)

		svg.append("rect").attr("x",leftMargin + pos).attr("y",textMargin+5).attr("width",squareWidth).attr("height",20).attr("fill",transformer(v)).attr("v",v).attr("fill-opacity",0.3)
	}
}

var drawMapStates = function(error,data)
{
    let div = d3.select("body").append("div").attr("id","leafletmap")

    let map = new L.Map("leafletmap", {center: [-10.3333,-53.2], zoom: 4}).addLayer(new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"));


    function parseCallback(responseText)
	{
		var parser = d3.dsvFormat("~");
		return parser.parse(responseText)
	}

    //Aqui em vez de usar o d3 para desenhar o GeoJSON, usei a camada de GeoJson do leaflet.
    //A lógica de contagem de acidentes é a mesma do problema 1.
    function drawMapCallback(error, response)
    {
    	var accidentsData = parseCallback(response.responseText)

    	var accidentsCount = d3.nest().key(d=>d.ocorrencia_uf).rollup(v=>v.length).entries(accidentsData)
    	var rangeNumAccidents = d3.extent(accidentsCount,o=>o.value)

    	var colorScaler = d3.scaleSequential(d3.interpolateWarm).domain(rangeNumAccidents)

    	accidentsCountDict = {}

    	for(var i = 0 ; i < accidentsCount.length ; i++)
    	{
    		accidentsCountDict[accidentsCount[i].key] = accidentsCount[i].value
    	}

        //Essa função determina a cor do polígono do estado, de acordo com o número de acidentes.
        function featureStyle(feature)
        {
            let dict = {
                "fillColor": colorScaler(accidentsCountDict[feature.properties.sigla]),
                "color":"black",
                "stroke":false,
                "fillOpacity":0.3
            }
            return dict
        }

        L.geoJSON(data,{style:function(feature){return featureStyle(feature)}}).addTo(map);

    	addLegend(d3.select("body"), colorScaler, 500)
	}

    function drawMapCallback2(error, csv)
    {
        statesCodes = {11:"RO",28:"SE",12:"AC",29:"BA",13:"AM",31:"MG",14:"RR",32:"ES",15:"PA",33:"RJ",16:"AP",35:"SP",17:"TO",41:"PR",21:"MA",42:"SC",22:"PI",43:"RS",23:"CE",50:"MS",24:"RN",51:"MT",25:"PB",52:"GO",26:"PE",53:"DF",27:"AL"}
        
        var gradesByState = d3.nest()
                            .key(function(d) { return d.CO_UF_CURSO; })
                            .rollup(function(v) { return d3.mean(v, function(d) { return d.NT_GER; }); })
                            .entries(csv)
                            
        gradesDict = {}
        
        gradesByState.forEach(d=>gradesDict[statesCodes[d.key]] = d.value)
        
    	var colorScaler = d3.scaleSequential(d3.interpolateWarm).domain([0,93.2])
    	
    	function featureStyle(feature)
        {
            a = 1
            let dict = {
                "fillColor": colorScaler(gradesDict[feature.properties.sigla]),
                "color":"black",
                "stroke":false,
                "fillOpacity":0.3
            }
            return dict
        }
        //Adicionar hover com a nota
    	
    	L.geoJSON(data,{style:function(feature){return featureStyle(feature)}}).addTo(map);
    	addLegend(d3.select("body"), colorScaler, 500)
    }
    d3.csv('dados_enade_red.csv').get(drawMapCallback2)



    
    //d3.request("https://raw.githubusercontent.com/nosbielcs/opendata_aig_brazil/master/data/oco.csv").get(drawMapCallback)
}


var drawStatesVis = function()
{
	d3.json("https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/brazil-states.geojson",drawMapStates)
}

var callbackSelectVis = function(event)
{ 
   	body = d3.select("body")
    body.selectAll("svg").remove()
    body.selectAll("div").remove()
	
    var selected = event.target.value

    if(selected == "vis1")
    {
        drawCitiesVis()
    }
    else if(selected == "vis2")
    {
        drawStatesVis()
    }
    else if(selected == "vis3")
    {
        drawCitiesVis2()
    }
}

//var formElement = document.querySelector('form#selectvis')
//formElement.addEventListener('change', callbackSelectVis);

drawStatesVis()


</script>

</body>
<html>
