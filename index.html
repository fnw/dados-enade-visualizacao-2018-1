<html>
<meta charset="utf-8"></meta>
<head>
 <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
   integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
   crossorigin=""/>
<title>Index</title>
</head>

<style>
#leafletmap {
  width: 500px;
  height: 500px;
}

</style>
<body>

<!-- Usei o código de quando eu tentei fazer um clone daqueles "batalha de favoritos" -->



<form id="selectvis">
    <label><input type="radio" id="vis1" name="w" value="vis1"> Notas por Estado </input></label>  
    <label><input type="radio" id="vis2" name="w" value="vis2"> Notas por Instituição</input></label> 
</form>

<select id="dropdown"> <!--Supplement an id here instead of using 'text'-->
  <option value="mean">Nota média</option> 
  <option value="top">1% melhores</option>
  <option value="bottom">1% piores</option>
</select>


 <!-- Make sure you put this AFTER Leaflet's CSS -->
<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
   integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
   crossorigin=""></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="crossfilter.min.js"></script>
<script type="text/javascript">

//Variáveis globais do mapa do Leaflet

var myMap = null;
var div = d3.select("body").append("div").attr("id","leafletmap");
var geoLayer = null;

//Variáveis de estado
var selectedVis = null;

//Variáveis de dados

var entireData = null;
var cf = null
var gradesDimension = null;


//Seletores e callbacks

//Funções
function drawMapInitial()
{
    myMap = new L.Map("leafletmap", {center: [-10.3333,-53.2], zoom: 4}).addLayer(new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"));
}


//Função que faz a legenda
//Cria uma série de pequenos retângulos com as cores da escala, para representar a estala.
var addLegend = function(target, transformer, width)
{
    textMargin = 30
    leftMargin = 15
    //Eu usei let aqui porque eu vi um exemplo de coisas dando errado com var quando você usa múltiplas cópias de uma mesma função de certas formas.
    //Além do tamanho dos retângulos, deixamos uma margem para o texto.
    let svg = target.append("svg").attr("width",width + leftMargin + 30).attr("height",20 + textMargin + 5).attr("id","legend")

    let squareWidth = 5

    let [lb,ub] = transformer.domain()

    //Uma escala para converter a posição do retângulo no svg para uma cor da escala.
    let posScaler = d3.scaleLinear().domain([0,width]).range(transformer.domain())

    //Adicionando o texto com os limites superiores e inferiores da escala.
    svg.append("text").attr("x",0).attr("y",15).text(lb)
    svg.append("text").attr("x",width - squareWidth).attr("y",15).text(ub)

	for(let pos = 0; pos < width; pos += squareWidth)
	{
		v = posScaler(pos)

		svg.append("rect").attr("x",leftMargin + pos).attr("y",textMargin+5).attr("width",squareWidth).attr("height",20).attr("fill",transformer(v)).attr("v",v).attr("fill-opacity",0.3)
	}
}

function drawStatesVis(error,data)
{   
    function drawBottom()
    {
    
        function isNumeric(n)
        {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
        
        statesCodes = {11:"RO",28:"SE",12:"AC",29:"BA",13:"AM",31:"MG",14:"RR",32:"ES",15:"PA",33:"RJ",16:"AP",35:"SP",17:"TO",41:"PR",21:"MA",42:"SC",22:"PI",43:"RS",23:"CE",50:"MS",24:"RN",51:"MT",25:"PB", 52:"GO",26:"PE",53:"DF",27:"AL"}
        
        if(cf == null)
        {
            cf = crossfilter(entireData)        
        }
        
        if(gradesDimension == null)
        {
            gradesDimension = cf.dimension(d=>d.NT_GER)
        }
        
        gradesDimension.filter(d=>isNumeric(d))
        
        let top1value = 0.01 * cf.size()
        
        let top1 = gradesDimension.bottom(top1value) 
        
        let countsByState = d3.nest()
                            .key(function(d) { return d.CO_UF_CURSO; })
                            .rollup(function(v) { return v.length;})
                            .entries(top1)
                            
        let countsDict = {}
              
        countsByState.forEach(d=>countsDict[statesCodes[d.key]] = d.value)
               
        let domain = d3.extent(countsByState,d=>d.value)
        domain[0] = 0.9 * domain[0]
        domain[1] = 1.1 * domain[1]
        
    	let colorScaler = d3.scaleSequential(d3.interpolateWarm).domain(domain)
    	
    	function featureStyle(feature)
        {
            let dict = {
                "fillColor": colorScaler(countsDict[feature.properties.sigla]),
                "color":"black",
                "stroke":false,
                "fillOpacity":0.3
            }
            return dict
        }
        geoLayer = L.geoJSON(data,{style:function(feature){return featureStyle(feature)}}).addTo(myMap);
    	addLegend(d3.select("body"), colorScaler, 500)
    	
    	gradesDimension.filterAll()
    }
    
    function drawTop()
    {
        statesCodes = {11:"RO",28:"SE",12:"AC",29:"BA",13:"AM",31:"MG",14:"RR",32:"ES",15:"PA",33:"RJ",16:"AP",35:"SP",17:"TO",41:"PR",21:"MA",42:"SC",22:"PI",43:"RS",23:"CE",50:"MS",24:"RN",51:"MT",25:"PB", 52:"GO",26:"PE",53:"DF",27:"AL"}
        
        if(cf == null)
        {
            cf = crossfilter(entireData)        
        }
        
        if(gradesDimension == null)
        {
            gradesDimension = cf.dimension(d=>d.NT_GER)
        }
        
        let top1value = 0.01 * cf.size()
        
        let top1 = gradesDimension.top(top1value) 
        
        let countsByState = d3.nest()
                            .key(function(d) { return d.CO_UF_CURSO; })
                            .rollup(function(v) { return v.length;})
                            .entries(top1)
                            
        let countsDict = {}
        
        countsByState.forEach(d=>countsDict[statesCodes[d.key]] = d.value)
               
        let domain = d3.extent(countsByState,d=>d.value)
        domain[0] = 0.9 * domain[0]
        domain[1] = 1.1 * domain[1]
        
    	let colorScaler = d3.scaleSequential(d3.interpolateWarm).domain(domain)
    	
    	function featureStyle(feature)
        {
            let dict = {
                "fillColor": colorScaler(countsDict[feature.properties.sigla]),
                "color":"black",
                "stroke":false,
                "fillOpacity":0.3
            }
            return dict
        }
        geoLayer = L.geoJSON(data,{style:function(feature){return featureStyle(feature)}}).addTo(myMap);
    	addLegend(d3.select("body"), colorScaler, 500)
    }
    
    function drawMean()
    {
        statesCodes = {11:"RO",28:"SE",12:"AC",29:"BA",13:"AM",31:"MG",14:"RR",32:"ES",15:"PA",33:"RJ",16:"AP",35:"SP",17:"TO",41:"PR",21:"MA",42:"SC",22:"PI",43:"RS",23:"CE",50:"MS",24:"RN",51:"MT",25:"PB",52:"GO",26:"PE",53:"DF",27:"AL"}
        
       
        
        let gradesByState = d3.nest()
                            .key(function(d) { return d.CO_UF_CURSO; })
                            .rollup(function(v) { return d3.mean(v, function(d) { return d.NT_GER; }); })
                            .entries(entireData)
                            
        let gradesDict = {}
        
        gradesByState.forEach(d=>gradesDict[statesCodes[d.key]] = d.value)
        
    	let colorScaler = d3.scaleSequential(d3.interpolateWarm).domain([0,50])
    	
    	function featureStyle(feature)
        {
            let dict = {
                "fillColor": colorScaler(gradesDict[feature.properties.sigla]),
                "color":"black",
                "stroke":false,
                "fillOpacity":0.3
            }
            return dict
        }
        geoLayer = L.geoJSON(data,{style:function(feature){return featureStyle(feature)}}).addTo(myMap);
    	addLegend(d3.select("body"), colorScaler, 500)
    }
    
    function draw()
    {
        if(selectedVis == 'mean')
        {
            drawMean()
        }
        else if(selectedVis == 'top')
        {
            drawTop()
        }
        else if(selectedVis == 'bottom')
        {
            drawBottom()
        }
    }    
    

    function fillAndDraw(error,csv)
    {
        console.log('Preencheu')
        entireData = csv;
        
        draw()
    }
    
    
    if(entireData == null)
    {
        console.log('Era null')
        d3.csv('dados_enade.csv').get(fillAndDraw)
    }
    else
    {	
        draw()
    }
}


var callbackSelectVis = function(event)
{ 
    let radioValue = document.querySelector('input[name="w"]:checked').value;
    
    let de = document.querySelector('select#dropdown')
    let dropdownValue = de.options[de.selectedIndex].value;    
     
    let vis = radioValue + '-' + dropdownValue
    selectedVis = dropdownValue
    
    console.log(selectedVis)
    
    d3.select("svg#legend").remove()
   	
   	if(geoLayer != null)
   	{
   	    myMap.removeLayer(geoLayer)
   	}
	
    
    if(radioValue == "vis1")
    {
        d3.json("https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/brazil-states.geojson",drawStatesVis)
    }
    else if(radioValue == "vis2")
    {
        console.log("nada")   
    }
}

var formElement = document.querySelector('form#selectvis')
formElement.addEventListener('change', callbackSelectVis);

var dropdownElement = document.querySelector('select#dropdown')
dropdownElement.addEventListener('change', callbackSelectVis);



drawMapInitial()


</script>

</body>
<html>
